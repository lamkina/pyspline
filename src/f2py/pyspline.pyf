!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module libspline ! in 
    interface  ! in :libspline
        subroutine basis(u,degree,knotvec,span,nctl,b) ! in :libspline:basis.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer intent(in) :: span
            integer, required,intent(in) :: nctl
            real(kind=realtype) dimension(1 + degree),intent(out),depend(degree) :: b
        end subroutine basis
        subroutine derivbasis(u,degree,knotvec,span,nctl,order,bd) ! in :libspline:basis.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer intent(in) :: span
            integer, required,intent(in) :: nctl
            integer intent(in) :: order
            real(kind=realtype) dimension(1 + min(degree, order),1 + degree),intent(out),depend(order,degree) :: bd
        end subroutine derivbasis
        subroutine bin(n,k,bincoeff) ! in :libspline:binomialCoeff.f90
            integer intent(in) :: n
            integer intent(in) :: k
            integer intent(out) :: bincoeff
        end subroutine bin
        subroutine evalcurve(u,knotvec,degree,p,nctl,ndim,npts,val) ! in :libspline:evalCurve.f90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 1) == nctl),depend(p) :: nctl=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(npts,ndim) :: val
        end subroutine evalcurve
        subroutine derivevalcurve(u,knotvec,degree,p,order,nctl,ndim,ck) ! in :libspline:evalCurve.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: p
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(p, 1) == nctl),depend(p) :: nctl=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            real(kind=realtype) dimension(ndim,1 + order),intent(out),depend(order,ndim) :: ck
        end subroutine derivevalcurve
        subroutine evalcurvenurbs(u,knotvec,degree,pw,nctl,ndim,npts,val,w) ! in :libspline:evalCurveNURBS.f90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 1) == nctl),depend(pw) :: nctl=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(npts,ndim) :: val
            real(kind=realtype) dimension(npts),intent(out),depend(npts) :: w
        end subroutine evalcurvenurbs
        subroutine derivevalcurvenurbs(u,knotvec,degree,pw,order,nctl,ndim,ck) ! in :libspline:evalCurveNURBS.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(pw, 1) == nctl),depend(pw) :: nctl=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            real(kind=realtype) dimension(-1 + ndim,1 + order),intent(out),depend(order,ndim) :: ck
        end subroutine derivevalcurvenurbs
        subroutine evalsurface(u,v,uknotvec,vknotvec,udegree,vdegree,p,nctlu,nctlv,ndim,n,m,val) ! in :libspline:evalSurface.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(m,n,ndim) :: val
        end subroutine evalsurface
        subroutine derivevalsurface(u,v,uknotvec,vknotvec,udegree,vdegree,p,order,nctlu,nctlv,ndim,skl) ! in :libspline:evalSurface.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) intent(in) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            real(kind=realtype) dimension(ndim,1 + order,1 + order),intent(out),depend(order,ndim) :: skl
        end subroutine derivevalsurface
        subroutine evalsurfacenurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,m,n,val) ! in :libspline:evalSurfaceNURBS.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, optional,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(m,n,ndim) :: val
        end subroutine evalsurfacenurbs
        subroutine derivevalsurfacenurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,order,skl) ! in :libspline:evalSurfaceNURBS.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) intent(in) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, optional,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer intent(in) :: order
            real(kind=realtype) dimension(ndim - 1,1 + order,1 + order),intent(out),depend(order,ndim) :: skl
        end subroutine derivevalsurfacenurbs
        subroutine findspan(u,degree,knotvec,nctl,span) ! in :libspline:findSpan.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: nctl
            integer intent(out) :: span
        end subroutine findspan
        subroutine multiplicity(u,knotvec,nctl,degree,mult) ! in :libspline:multiplicity.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: nctl
            integer, required,intent(in) :: degree
            integer intent(out) :: mult
        end subroutine multiplicity
        subroutine buildcurvecoeffmatrix(u,ud,knotvec,degree,nctl,n,nd,vals,row_ptr,col_ind) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(n),intent(in) :: u
            real(kind=realtype) dimension(nd),intent(in) :: ud
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(degree,nctl) :: knotvec
            integer, required,intent(in) :: degree
            integer, required,intent(in) :: nctl
            integer, optional,intent(in),check(shape(u, 0) == n),depend(u) :: n=shape(u, 0)
            integer, optional,intent(in),check(shape(ud, 0) == nd),depend(ud) :: nd=shape(ud, 0)
            real(kind=realtype) dimension(n + nd + degree * n + degree * nd),intent(inout),check(shape(vals, 0) == n + nd + degree * n + degree * nd),depend(n,nd,degree) :: vals
            integer dimension(1 + n + nd),intent(inout),depend(n,nd) :: row_ptr
            integer dimension(n + nd + degree * n + degree * nd),intent(inout),check(shape(col_ind, 0) == n + nd + degree * n + degree * nd),depend(n,nd,degree) :: col_ind
        end subroutine buildcurvecoeffmatrix
        subroutine polylength(x,n,ndim,length) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(ndim,n),intent(in) :: x
            integer, optional,intent(in),check(shape(x, 1) == n),depend(x) :: n=shape(x, 1)
            integer, optional,intent(in),check(shape(x, 0) == ndim),depend(x) :: ndim=shape(x, 0)
            real(kind=realtype) intent(out) :: length
        end subroutine polylength
        subroutine buildcurveconjac(aval,arowptr,acolind,bval,browptr,bcolind,cval,crowptr,ccolind,am,an,cm,annz,bnnz,cnnz,jval,jcolind,jrowptr) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(annz),intent(in) :: aval
            integer dimension(1 + am),intent(in) :: arowptr
            integer dimension(annz),intent(in),depend(annz) :: acolind
            real(kind=realtype) dimension(bnnz),intent(in) :: bval
            integer dimension(1 + am),intent(in),depend(am) :: browptr
            integer dimension(bnnz),intent(in),depend(bnnz) :: bcolind
            real(kind=realtype) dimension(cnnz),intent(in) :: cval
            integer dimension(1 + cm),intent(in) :: crowptr
            integer dimension(cnnz),intent(in),depend(cnnz) :: ccolind
            integer, optional,intent(in),check(shape(arowptr, 0) == 1 + am),depend(arowptr) :: am=-1 + shape(arowptr, 0)
            integer intent(in) :: an
            integer, optional,intent(in),check(shape(crowptr, 0) == 1 + cm),depend(crowptr) :: cm=-1 + shape(crowptr, 0)
            integer, optional,intent(in),check(shape(aval, 0) == annz),depend(aval) :: annz=shape(aval, 0)
            integer, optional,intent(in),check(shape(bval, 0) == bnnz),depend(bval) :: bnnz=shape(bval, 0)
            integer, optional,intent(in),check(shape(cval, 0) == cnnz),depend(cval) :: cnnz=shape(cval, 0)
            real(kind=realtype) dimension(annz + bnnz + cnnz),intent(out),depend(annz,bnnz,cnnz) :: jval
            integer dimension(annz + bnnz + cnnz),intent(out),depend(annz,bnnz,cnnz) :: jcolind
            integer dimension(1 + am + cm),intent(out),depend(am,cm) :: jrowptr
        end subroutine buildcurveconjac
        subroutine curveparamcorr(knotvec,degree,u,coef,nctl,ndim,length,n,x) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(n),intent(inout) :: u
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: coef
            integer, optional,intent(in),check(shape(coef, 1) == nctl),depend(coef) :: nctl=shape(coef, 1)
            integer, optional,intent(in),check(shape(coef, 0) == ndim),depend(coef) :: ndim=shape(coef, 0)
            real(kind=realtype) intent(in) :: length
            integer, optional,intent(in),check(shape(u, 0) == n),depend(u) :: n=shape(u, 0)
            real(kind=realtype) dimension(ndim,n),intent(in),depend(ndim,n) :: x
        end subroutine curveparamcorr
        subroutine buildsurfacecoeffmatrix(u,v,uknotvec,vknotvec,udegree,vdegree,nctlu,nctlv,nu,nv,vals,rowptr,colind) ! in :libspline:surfaceFitting.f90
            use precision
            real(kind=realtype) dimension(nv,nu),intent(in) :: u
            real(kind=realtype) dimension(nv,nu),intent(in),depend(nu,nv) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(vdegree,nctlv) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            integer, required,intent(in) :: nctlu
            integer, required,intent(in) :: nctlv
            integer, optional,intent(in),check(shape(u, 1) == nu),depend(u) :: nu=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == nv),depend(u) :: nv=shape(u, 0)
            real(kind=realtype) dimension(nu * nv + nu * nv * udegree + nu * nv * udegree * vdegree + nu * nv * vdegree),intent(out),depend(nu,udegree,nv,vdegree) :: vals
            integer dimension(1 + nu * nv),intent(out),depend(nu,nv) :: rowptr
            integer dimension(nu * nv + nu * nv * udegree + nu * nv * udegree * vdegree + nu * nv * vdegree),intent(out),depend(nu,udegree,nv,vdegree) :: colind
        end subroutine buildsurfacecoeffmatrix
        subroutine surfaceparamcorr(uknotvec,vknotvec,udegree,vdegree,u,v,p,nctlu,nctlv,ndim,nu,nv,x,rms) ! in :libspline:surfaceFitting.f90
            use precision
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(nctlu,udegree) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(nv,nu),intent(inout) :: u
            real(kind=realtype) dimension(nv,nu),intent(inout),depend(nu,nv) :: v
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == nu),depend(u) :: nu=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == nv),depend(u) :: nv=shape(u, 0)
            real(kind=realtype) dimension(ndim,nv,nu),intent(in),depend(nu,nv,ndim) :: x
            real(kind=realtype) intent(out) :: rms
        end subroutine surfaceparamcorr
        subroutine pointcurve(points,knotvec,degree,pw,niter,eps,u,nctl,ndim,diff) ! in :libspline.projections.F90
            use precision
            real(kind=realtype) dimension(3),intent(in) :: points
            real(kind=realtype) dimension(nctl+degree+1),intent(in),depend(degree,nctl) :: knotvec
            integer intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer intent(in) :: niter
            real(kind=realtype) intent(in) :: eps
            real(kind=realtype) intent(in,out) :: u
            integer, optional,intent(in),check(shape(pw,1)==nctl),depend(pw) :: nctl=shape(pw,1)
            integer, optional,intent(in),check(shape(pw,0)==ndim),depend(pw) :: ndim=shape(pw,0)
            real(kind=realtype) dimension(3),intent(out) :: diff
        end subroutine pointcurve
        subroutine pointcurvestart(points,u,data,nu,ndim,n,uguess) ! in :libspline:projections.F90
            use precision
            real(kind=realtype) dimension(ndim,n),intent(in) :: points
            real(kind=realtype) dimension(nu),intent(in) :: u
            real(kind=realtype) dimension(ndim,nu),intent(in),depend(nu,ndim) :: data
            integer, optional,intent(in),check(shape(u, 0) == nu),depend(u) :: nu=shape(u, 0)
            integer, optional,intent(in),check(shape(points, 0) == ndim),depend(points) :: ndim=shape(points, 0)
            integer, optional,intent(in),check(shape(points, 1) == n),depend(points) :: n=shape(points, 1)
            real(kind=realtype) dimension(n),intent(out),depend(n) :: uguess
        end subroutine pointcurvestart
    end interface
end python module libspline

! This file was auto-generated with f2py (version:1.24.2).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
