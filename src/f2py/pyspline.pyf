!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module libspline ! in 
    interface  ! in :libspline
        subroutine evalcurve(u,knotvec,degree,p,nctl,ndim,npts,val) ! in :libspline:evalCurve.f90
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 1) == nctl),depend(p) :: nctl=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(ndim,npts) :: val
        end subroutine evalcurve
        subroutine evalcurvenurbs(u,knotvec,degree,pw,nctl,ndim,npts,val) ! in :libspline:evalCurveNURBS.f90
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 1) == nctl),depend(pw) :: nctl=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(ndim,npts) :: val
        end subroutine evalcurvenurbs
        subroutine evalsurface(u,v,uknotvec,vknotvec,udegree,vdegree,p,nctlu,nctlv,ndim,n,m,val) ! in :libspline:evalSurface.f90
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(vdegree,nctlv) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, required,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, required,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(ndim,n,m) :: val
        end subroutine evalsurface
        subroutine evalsurfacenurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,m,n,val) ! in :libspline:evalSurfaceNURBS.f90
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(vdegree,nctlv) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(1 + ndim,nctlv,nctlu),intent(in) :: pw
            integer, required,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, required,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == 1 + ndim),depend(pw) :: ndim=-1 + shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(ndim,n,m) :: val
        end subroutine evalsurfacenurbs
        subroutine basis(u,degree,knotvec,span,nctl,b) ! in :libspline:basis.f90
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer intent(in) :: span
            integer, required,intent(in) :: nctl
            real(kind=realtype) dimension(1 + degree),intent(out),depend(degree) :: b
        end subroutine basis
        subroutine findspan(u,degree,knotvec,nctl,span) ! in :libspline:findSpan.f90
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: nctl
            integer intent(out) :: span
        end subroutine findspan
    end interface 
end python module libspline

! This file was auto-generated with f2py (version:1.24.2).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
