!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module libspline ! in 
    interface  ! in :libspline
        subroutine basis(u,degree,knotvec,span,nctl,b) ! in :libspline:basis.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer intent(in) :: span
            integer, required,intent(in) :: nctl
            real(kind=realtype) dimension(1 + degree),intent(out),depend(degree) :: b
        end subroutine basis
        subroutine derivbasis(u,degree,knotvec,span,nctl,order,bd) ! in :libspline:basis.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer intent(in) :: span
            integer, required,intent(in) :: nctl
            integer intent(in) :: order
            real(kind=realtype) dimension(1 + min(degree, order),1 + degree),intent(out),depend(order,degree) :: bd
        end subroutine derivbasis
        subroutine bin(n,k,bincoeff) ! in :libspline:binomialCoeff.f90
            integer intent(in) :: n
            integer intent(in) :: k
            integer intent(out) :: bincoeff
        end subroutine bin
        subroutine evalcurve(u,knotvec,degree,p,nctl,ndim,npts,val) ! in :libspline:evalCurve.f90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 1) == nctl),depend(p) :: nctl=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(npts,ndim) :: val
        end subroutine evalcurve
        subroutine derivevalcurve(u,knotvec,degree,p,order,nctl,ndim,ck) ! in :libspline:evalCurve.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: p
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(p, 1) == nctl),depend(p) :: nctl=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            real(kind=realtype) dimension(ndim,1 + order),intent(out),depend(order,ndim) :: ck
        end subroutine derivevalcurve
        subroutine evalcurvenurbs(u,knotvec,degree,pw,nctl,ndim,npts,val,w) ! in :libspline:evalCurveNURBS.f90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 1) == nctl),depend(pw) :: nctl=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == npts),depend(u) :: npts=shape(u, 0)
            real(kind=realtype) dimension(ndim,npts),intent(out),depend(npts,ndim) :: val
            real(kind=realtype) dimension(npts),intent(out),depend(npts) :: w
        end subroutine evalcurvenurbs
        subroutine derivevalcurvenurbs(u,knotvec,degree,pw,order,nctl,ndim,ck) ! in :libspline:evalCurveNURBS.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(pw, 1) == nctl),depend(pw) :: nctl=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            real(kind=realtype) dimension(-1 + ndim,1 + order),intent(out),depend(order,ndim) :: ck
        end subroutine derivevalcurvenurbs
        subroutine evalsurface(u,v,uknotvec,vknotvec,udegree,vdegree,p,nctlu,nctlv,ndim,n,m,val) ! in :libspline:evalSurface.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(m,n,ndim) :: val
        end subroutine evalsurface
        subroutine derivevalsurface(u,v,uknotvec,vknotvec,udegree,vdegree,p,order,nctlu,nctlv,ndim,skl) ! in :libspline:evalSurface.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) intent(in) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer intent(in) :: order
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            real(kind=realtype) dimension(ndim,1 + order,1 + order),intent(out),depend(order,ndim) :: skl
        end subroutine derivevalsurface
        subroutine evalsurfacenormals(u,v,uknotvec,vknotvec,udegree,vdegree,p,nctlu,nctlv,ndim,n,m,normals) ! in :libspline:evalSurface.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(m,n,ndim) :: normals
        end subroutine evalsurfacenormals
        subroutine evalsurfacenurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,m,n,val) ! in :libspline:evalSurfaceNURBS.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, optional,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            real(kind=realtype) dimension(ndim,m,n),intent(out),depend(m,n,ndim) :: val
        end subroutine evalsurfacenurbs
        subroutine derivevalsurfacenurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,order,skl) ! in :libspline:evalSurfaceNURBS.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) intent(in) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, optional,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer intent(in) :: order
            real(kind=realtype) dimension(ndim - 1,1 + order,1 + order),intent(out),depend(order,ndim) :: skl
        end subroutine derivevalsurfacenurbs
        subroutine evalsurfacenormalsnurbs(u,v,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,m,n,normals) ! in :libspline:evalSurfaceNURBS.f90
            use precision
            real(kind=realtype) dimension(m,n),intent(in) :: u
            real(kind=realtype) dimension(m,n),intent(in),depend(m,n) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw, 2) == nctlu),depend(pw) :: nctlu=shape(pw, 2)
            integer, optional,intent(in),check(shape(pw, 1) == nctlv),depend(pw) :: nctlv=shape(pw, 1)
            integer, optional,intent(in),check(shape(pw, 0) == ndim),depend(pw) :: ndim=shape(pw, 0)
            integer, optional,intent(in),check(shape(u, 0) == m),depend(u) :: m=shape(u, 0)
            integer, optional,intent(in),check(shape(u, 1) == n),depend(u) :: n=shape(u, 1)
            real(kind=realtype) dimension(ndim - 1,m,n),intent(out),depend(m,n,ndim) :: normals
        end subroutine evalsurfacenormalsnurbs
        subroutine findspan(u,degree,knotvec,nctl,span) ! in :libspline:findSpan.f90
            use precision
            real(kind=realtype) intent(in) :: u
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: nctl
            integer intent(out) :: span
        end subroutine findspan
        subroutine multiplicity(u,knotvec,nctl,degree,mult) ! in :libspline:multiplicity.f90
            use precision
            real(kind=realtype) intent(in) :: u
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: nctl
            integer, required,intent(in) :: degree
            integer intent(out) :: mult
        end subroutine multiplicity
        subroutine buildcurvecoeffmatrix(u,ud,knotvec,degree,nctl,n,nd,vals,row_ptr,col_ind) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(n),intent(in) :: u
            real(kind=realtype) dimension(nd),intent(in) :: ud
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(degree,nctl) :: knotvec
            integer, required,intent(in) :: degree
            integer, required,intent(in) :: nctl
            integer, optional,intent(in),check(shape(u, 0) == n),depend(u) :: n=shape(u, 0)
            integer, optional,intent(in),check(shape(ud, 0) == nd),depend(ud) :: nd=shape(ud, 0)
            real(kind=realtype) dimension(n + nd + degree * n + degree * nd),intent(inout),check(shape(vals, 0) == n + nd + degree * n + degree * nd),depend(n,nd,degree) :: vals
            integer dimension(1 + n + nd),intent(inout),depend(n,nd) :: row_ptr
            integer dimension(n + nd + degree * n + degree * nd),intent(inout),check(shape(col_ind, 0) == n + nd + degree * n + degree * nd),depend(n,nd,degree) :: col_ind
        end subroutine buildcurvecoeffmatrix
        subroutine polylength(x,n,ndim,length) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(ndim,n),intent(in) :: x
            integer, optional,intent(in),check(shape(x, 1) == n),depend(x) :: n=shape(x, 1)
            integer, optional,intent(in),check(shape(x, 0) == ndim),depend(x) :: ndim=shape(x, 0)
            real(kind=realtype) intent(out) :: length
        end subroutine polylength
        subroutine buildcurveconjac(aval,arowptr,acolind,bval,browptr,bcolind,cval,crowptr,ccolind,am,an,cm,annz,bnnz,cnnz,jval,jcolind,jrowptr) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(annz),intent(in) :: aval
            integer dimension(1 + am),intent(in) :: arowptr
            integer dimension(annz),intent(in),depend(annz) :: acolind
            real(kind=realtype) dimension(bnnz),intent(in) :: bval
            integer dimension(1 + am),intent(in),depend(am) :: browptr
            integer dimension(bnnz),intent(in),depend(bnnz) :: bcolind
            real(kind=realtype) dimension(cnnz),intent(in) :: cval
            integer dimension(1 + cm),intent(in) :: crowptr
            integer dimension(cnnz),intent(in),depend(cnnz) :: ccolind
            integer, optional,intent(in),check(shape(arowptr, 0) == 1 + am),depend(arowptr) :: am=-1 + shape(arowptr, 0)
            integer intent(in) :: an
            integer, optional,intent(in),check(shape(crowptr, 0) == 1 + cm),depend(crowptr) :: cm=-1 + shape(crowptr, 0)
            integer, optional,intent(in),check(shape(aval, 0) == annz),depend(aval) :: annz=shape(aval, 0)
            integer, optional,intent(in),check(shape(bval, 0) == bnnz),depend(bval) :: bnnz=shape(bval, 0)
            integer, optional,intent(in),check(shape(cval, 0) == cnnz),depend(cval) :: cnnz=shape(cval, 0)
            real(kind=realtype) dimension(annz + bnnz + cnnz),intent(out),depend(annz,bnnz,cnnz) :: jval
            integer dimension(annz + bnnz + cnnz),intent(out),depend(annz,bnnz,cnnz) :: jcolind
            integer dimension(1 + am + cm),intent(out),depend(am,cm) :: jrowptr
        end subroutine buildcurveconjac
        subroutine curveparamcorr(knotvec,degree,u,coef,nctl,ndim,length,n,x) ! in :libspline:curveFitting.f90
            use precision
            real(kind=realtype) dimension(1 + degree + nctl),intent(in),check(shape(knotvec, 0) == 1 + degree + nctl,shape(knotvec, 0) == 1 + degree + nctl),depend(nctl,degree) :: knotvec
            integer, required,intent(in) :: degree
            real(kind=realtype) dimension(n),intent(inout) :: u
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: coef
            integer, optional,intent(in),check(shape(coef, 1) == nctl),depend(coef) :: nctl=shape(coef, 1)
            integer, optional,intent(in),check(shape(coef, 0) == ndim),depend(coef) :: ndim=shape(coef, 0)
            real(kind=realtype) intent(in) :: length
            integer, optional,intent(in),check(shape(u, 0) == n),depend(u) :: n=shape(u, 0)
            real(kind=realtype) dimension(ndim,n),intent(in),depend(ndim,n) :: x
        end subroutine curveparamcorr
        subroutine buildsurfacecoeffmatrix(u,v,uknotvec,vknotvec,udegree,vdegree,nctlu,nctlv,nu,nv,vals,rowptr,colind) ! in :libspline:surfaceFitting.f90
            use precision
            real(kind=realtype) dimension(nv,nu),intent(in) :: u
            real(kind=realtype) dimension(nv,nu),intent(in),depend(nu,nv) :: v
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(vdegree,nctlv) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            integer, required,intent(in) :: nctlu
            integer, required,intent(in) :: nctlv
            integer, optional,intent(in),check(shape(u, 1) == nu),depend(u) :: nu=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == nv),depend(u) :: nv=shape(u, 0)
            real(kind=realtype) dimension(nu * nv + nu * nv * udegree + nu * nv * udegree * vdegree + nu * nv * vdegree),intent(out),depend(nu,udegree,nv,vdegree) :: vals
            integer dimension(1 + nu * nv),intent(out),depend(nu,nv) :: rowptr
            integer dimension(nu * nv + nu * nv * udegree + nu * nv * udegree * vdegree + nu * nv * vdegree),intent(out),depend(nu,udegree,nv,vdegree) :: colind
        end subroutine buildsurfacecoeffmatrix
        subroutine surfaceparamcorr(uknotvec,vknotvec,udegree,vdegree,u,v,p,nctlu,nctlv,ndim,nu,nv,x,rms) ! in :libspline:surfaceFitting.f90
            use precision
            real(kind=realtype) dimension(1 + nctlu + udegree),intent(in),check(shape(uknotvec, 0) == 1 + nctlu + udegree,shape(uknotvec, 0) == 1 + nctlu + udegree),depend(nctlu,udegree) :: uknotvec
            real(kind=realtype) dimension(1 + nctlv + vdegree),intent(in),check(shape(vknotvec, 0) == 1 + nctlv + vdegree,shape(vknotvec, 0) == 1 + nctlv + vdegree),depend(nctlv,vdegree) :: vknotvec
            integer, required,intent(in) :: udegree
            integer, required,intent(in) :: vdegree
            real(kind=realtype) dimension(nv,nu),intent(inout) :: u
            real(kind=realtype) dimension(nv,nu),intent(inout),depend(nu,nv) :: v
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: p
            integer, optional,intent(in),check(shape(p, 2) == nctlu),depend(p) :: nctlu=shape(p, 2)
            integer, optional,intent(in),check(shape(p, 1) == nctlv),depend(p) :: nctlv=shape(p, 1)
            integer, optional,intent(in),check(shape(p, 0) == ndim),depend(p) :: ndim=shape(p, 0)
            integer, optional,intent(in),check(shape(u, 1) == nu),depend(u) :: nu=shape(u, 1)
            integer, optional,intent(in),check(shape(u, 0) == nv),depend(u) :: nv=shape(u, 0)
            real(kind=realtype) dimension(ndim,nv,nu),intent(in),depend(nu,nv,ndim) :: x
            real(kind=realtype) intent(out) :: rms
        end subroutine surfaceparamcorr
        subroutine pointcurve(points,u0,knotvec,degree,pw,nctl,ndim,rational,lb,ub,tol,maxiter,maxiterls,alpha0,rho,wolfe,printlevel,npts,u,diff) ! in :libspline:projections.F90
            use precision
            real(kind=realtype) dimension(npts,ndim),intent(in),depend(ndim) :: points
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: u0
            real(kind=realtype) dimension(nctl+degree+1),intent(in),depend(degree,nctl) :: knotvec
            integer intent(in) :: degree
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw,1)==nctl),depend(pw) :: nctl=shape(pw,1)
            integer, optional,intent(in),check(shape(pw,0)==ndim),depend(pw) :: ndim=shape(pw,0)
            logical intent(in) :: rational
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: lb
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: ub
            real(kind=realtype) intent(in) :: tol
            integer intent(in) :: maxiter
            integer intent(in) :: maxiterls
            real(kind=realtype) intent(in) :: alpha0
            real(kind=realtype) intent(in) :: rho
            real(kind=realtype) intent(in) :: wolfe
            integer intent(in) :: printlevel
            integer, optional,intent(in),check(len(points)>=npts),depend(points) :: npts=len(points)
            real(kind=realtype) dimension(npts),intent(out),depend(npts) :: u
            real(kind=realtype) dimension(npts,ndim),intent(out),depend(npts, ndim) :: diff
        end subroutine pointcurve
        subroutine curvecurve(u0,knotvec1,degree1,pw1,knotvec2,degree2,pw2,nctl1,nctl2,ndim,rational1,rational2,lb,ub,tol,maxiter,maxiterls,alpha0,rho,wolfe,printlevel,u,diff) ! in :libspline:projections.F90
            use precision
            real(kind=realtype) dimension(2),intent(in) :: u0
            real(kind=realtype) dimension(nctl1+degree1+1),intent(in),depend(degree1,nctl1) :: knotvec1
            integer intent(in) :: degree1
            real(kind=realtype) dimension(ndim,nctl1),intent(in) :: pw1
            real(kind=realtype) dimension(nctl2+degree2+1),intent(in),depend(degree2,nctl2) :: knotvec2
            integer intent(in) :: degree2
            real(kind=realtype) dimension(ndim,nctl2),intent(in),depend(ndim) :: pw2
            integer, optional,intent(in),check(shape(pw1,1)==nctl1),depend(pw1) :: nctl1=shape(pw1,1)
            integer, optional,intent(in),check(shape(pw2,1)==nctl2),depend(pw2) :: nctl2=shape(pw2,1)
            integer, optional,intent(in),check(shape(pw1,0)==ndim),depend(pw1) :: ndim=shape(pw1,0)
            logical intent(in) :: rational1
            logical intent(in) :: rational2
            real(kind=realtype) dimension(2),intent(in) :: lb
            real(kind=realtype) dimension(2),intent(in) :: ub
            real(kind=realtype) intent(in) :: tol
            integer intent(in) :: maxiter
            integer intent(in) :: maxiterls
            real(kind=realtype) intent(in) :: alpha0
            real(kind=realtype) intent(in) :: rho
            real(kind=realtype) intent(in) :: wolfe
            integer intent(in) :: printlevel
            real(kind=realtype) dimension(2),intent(out) :: u
            real(kind=realtype) dimension(ndim),intent(out),depend(ndim) :: diff
        end subroutine curvecurve
        subroutine pointcurvestart(points,u,data,nu,ndim,n,uguess) ! in :libspline:projections.F90
            use precision
            real(kind=realtype) dimension(ndim,n),intent(in) :: points
            real(kind=realtype) dimension(nu),intent(in) :: u
            real(kind=realtype) dimension(ndim,nu),intent(in),depend(nu,ndim) :: data
            integer, optional,intent(in),check(shape(u, 0) == nu),depend(u) :: nu=shape(u, 0)
            integer, optional,intent(in),check(shape(points, 0) == ndim),depend(points) :: ndim=shape(points, 0)
            integer, optional,intent(in),check(shape(points, 1) == n),depend(points) :: n=shape(points, 1)
            real(kind=realtype) dimension(n),intent(out),depend(n) :: uguess
        end subroutine pointcurvestart
        subroutine curvecurvestart(data1,uu1,data2,uu2,nu1,nu2,ndim,s1,s2) ! in :libspline:projections.F90
            real(kind=realtype) dimension(ndim,nu1),intent(in) :: data1
            real(kind=realtype) dimension(nu1),intent(in),depend(nu1) :: uu1
            real(kind=realtype) dimension(ndim,nu2),intent(in),depend(ndim) :: data2
            real(kind=realtype) dimension(nu2),intent(in),depend(nu2) :: uu2
            integer, optional,intent(in),check(shape(data1,1)==nu1),depend(data1) :: nu1=shape(data1,1)
            integer, optional,intent(in),check(shape(data2,1)==nu2),depend(data2) :: nu2=shape(data2,1)
            integer, optional,intent(in),check(shape(data1,0)==ndim),depend(data1) :: ndim=shape(data1,0)
            real(kind=realtype) intent(out) :: s1
            real(kind=realtype) intent(out) :: s2
        end subroutine curvecurvestart
        subroutine pointinvcurve(xstar,coord,u0,lb,ub,maxiter,tol,printlevel,knotvec,degree,pw,nctl,ndim,npts,ustar) ! in :libspline:pointInversion.F90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: xstar
            integer intent(in) :: coord
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: u0
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: lb
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: ub
            integer intent(in) :: maxiter
            real(kind=realtype) intent(in) :: tol
            integer intent(in) :: printlevel
            integer intent(in) :: degree
            real(kind=realtype) dimension(nctl+degree+1),intent(in),depend(degree,nctl) :: knotvec
            real(kind=realtype) dimension(ndim,nctl),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw,1)==nctl),depend(pw) :: nctl=shape(pw,1)
            integer, optional,intent(in),check(shape(pw,0)==ndim),depend(pw) :: ndim=shape(pw,0)
            integer, optional,intent(in),check(len(xstar)>=npts),depend(xstar) :: npts=len(xstar)
            real(kind=realtype) dimension(npts),intent(out),depend(npts) :: ustar
        end subroutine pointinvcurve
        subroutine pointinvsurface(xstar,coords,u0,lb,ub,maxiter,tol,printlevel,uknotvec,vknotvec,udegree,vdegree,pw,nctlu,nctlv,ndim,npts,ustar) ! in pointInversion.f90
            use precision
            real(kind=realtype) dimension(npts),intent(in) :: xstar
            integer dimension(2),intent(in) :: coords
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: u0
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: lb
            real(kind=realtype) dimension(npts),intent(in),depend(npts) :: ub
            integer intent(in) :: maxiter
            real(kind=realtype) intent(in) :: tol
            integer intent(in) :: printlevel
            real(kind=realtype) dimension(nctlu+udegree+1),intent(in),depend(udegree,nctlu) :: uknotvec
            real(kind=realtype) dimension(nctlv+vdegree+1),intent(in),depend(vdegree,nctlv) :: vknotvec
            integer intent(in) :: udegree
            integer intent(in) :: vdegree
            real(kind=realtype) dimension(ndim,nctlv,nctlu),intent(in) :: pw
            integer, optional,intent(in),check(shape(pw,2)==nctlu),depend(pw) :: nctlu=shape(pw,2)
            integer, optional,intent(in),check(shape(pw,1)==nctlv),depend(pw) :: nctlv=shape(pw,1)
            integer, optional,intent(in),check(shape(pw,0)==ndim),depend(pw) :: ndim=shape(pw,0)
            integer, optional,intent(in),check(len(xstar)>=npts),depend(xstar) :: npts=len(xstar)
            real(kind=realtype) dimension(npts),intent(out),depend(npts) :: ustar
        end subroutine pointinvsurface
    end interface
end python module libspline

! This file was auto-generated with f2py (version:1.24.2).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
